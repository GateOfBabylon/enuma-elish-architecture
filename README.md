# Димпомна работа:

Създаване на domain-specific language (DSL) за изпълняване на HTTP заявки и/или Python скриптове в Docker контейнери. 

### 1. **Цел на дипломната работа:**
Целта на проекта е създаване на DSL, който да позволява описването на различни команди за изпълнение на HTTP заявки и Python скриптове в Docker контейнери. Тези команди ще бъдат структурирани в екзекутори, които ще могат да се интерпретират и изпълняват на сървър.

### 2. Основни компоненти на проекта:

#### 2.1 DSL (Domain-Specific Language):

##### Цели:
- **Създаване на синтаксис за DSL, подобен на YAML,** с разширение на файл (например `.ea`[Enuma Elish]), който да описва екзекутори и техните задачи.
- **DSL-ът трябва да поддържа дефиниции за HTTP заявки и Python скриптове.**
- **Интерпретация на DSL-а в Go код:** Интерпретатор на GoLang, който изпълнява този DSL код.

##### Пример за синтаксис на DSL:

###### Пример за HTTP екзекутор:
```ea
executor:
  name: "delete-resource-if-exists"
  type: "http"
  env:
    user: "my_username"
    pass: ${{mycreds.password}}
    id: ${{mycreds.clientId}}
  tasks:
    - name: "ensure-token"
      method: "POST"
      url: "http://example.com/api/token"
      headers:
        Content-Type: "application/json"
      body: '{"username":${{user}}, "password":${{pass}}}'
      export: ${{token}}

    - name: "check-existing"
      method: "GET"
      url: "http://example.com/api/resource/${{id}}"
      headers:
        Authorization: "Bearer ${{token}}"
      export: ${{exists}}

    - name: "delete-by-id"
      method: "DELETE"
      condition: ${{exists}}
      url: "http://example.com/api/resource/${{id}}"
      headers:
        Authorization: "Bearer ${{token}}"
```

###### Пример за Python екзекутор (изпълняван в Docker контейнер):
```ea
executor:
  name: "py-docker-execution"
  type: "py"
  universe:
    world: "docker.io/python-execution-image:latest"
    secret: "python_execution_registry_credentials"
  env:
    arg1: ${{config.type}}
    arg2: ${{config.option}}
  tasks:
    - name: "install-curl"
      script: |
        import os
        x = os.getenv("X")
        print("Task completed: " + x)

    - name: "do-the-script"
      script-path: "./run.py ${{arg1}} ${{arg2}}"
      export: ${{result}}
```

#### 2.2. Интерпретатор:

##### Цели:
- **Да се изпълни DSL с Go код.**
- За всяка задача в DSL-а, ще бъде интерпретирана в съответната поредица инструкции на Go, които ще се изпълняват на сървъра.
- **За HTTP заявките:** ще се изпълни Go код, който изпраща HTTP заявки.
- **За Python командите:** ще се изпълни Go код, който стартира Docker контейнер и изпълнява Python скрипта вътре в него.

#### 2.3 Executor-и:

##### Цели:
- **HTTP Executor:** ще обработва дефинициите за HTTP заявки, включително методи, URL адреси, хедъри и тяло на заявката. Ще се генерира Go код за всяка задача, като всяка заявка ще се изпраща последователно.
  
- **Python Executor:** ще изпълнява Python скриптове в Docker контейнери. Ще се създава Docker контейнер за всяка заадча и скриптът ще се изпълнява вътре в контейнера.

#### 2.4 Docker:

##### Цели:
- **Изолиране на изпълнението на Python скриптове:** Всеки Python екзекутор ще стартира нов Docker контейнер, където ще се изпълни скрипта.
- **Docker управление:** Командите ще бъдат изпълнявани в контейнери, като изпълнението на контейнерите ще бъде управлявано чрез Docker CLI или API от генерирания Go код.


### 3. **Технологии и инструменти:**
- **Go** за изграждане на компилатора/интерпретатора, който ще преобразува DSL в изпълним Go код за HTTP заявки и Python скриптове в Docker контейнери.
- **Java Spring Boot** за разработка на backend сървър, който ще управлява изпълнението на екзекуторите. Сървърът ще предоставя REST API, чрез което външни приложения или потребителски интерфейси могат да подават задачи и да контролират изпълнението на генерирания Go код.
- **Docker** за управление на контейнерите и изолиране на средата за изпълнение на Python скриптовете. Всеки екзекутор ще стартира нов контейнер, където ще се изпълни съответният Python скрипт.
- **Angular** за създаване на фронт-енд потребителски интерфейс, където потребителите могат да дефинират екзекутори с помощта на DSL, да ги управляват и следят тяхното изпълнение.
- **Enuma Elish DSL (.ea)** – синтаксис, подобен на YAML (fully compatible), който ще описва екзекуторите и техните команди. Този DSL ще бъде лесен за четене и писане, като същевременно ще поддържа всички необходими функционалности за дефиниране на сложни задачи.
- **Go стандартна библиотека и Docker API/CLI** за изпълнение на генерираните команди, включително изпращане на HTTP заявки и стартиране на Docker контейнери.
  
### 4. **Етапи на реализация**

#### Етап 1: Проучване и дефиниране на DSL

1. **Проучване на съществуващи DSL-и**:
   - Определяне на структури и механизми, необходими за  DSL-а. Осигоряване на лесна четимост, разширяемост и интуитивност.

2. **Дефиниране на синтаксиса и семантиката**:
   - Описванр на  възможни команди и параметри, които DSL-ът ще поддържа.
   - Въвеждане на специфично разширение на файла за DSL-а, например `.ea` (Enuma Elish). Този файл ще съдържа дефинициите за командите.
   - Изготвяне на граматика на езика – как ще изглеждат различните конструкции, как ще се дефинират изпълнителни команди и връзките между тях.

#### Етап 2: Изграждане на интерпретатор/компилатор

1. **Дизайн на компилатора/интерпретатора**:
   - Определяне на основните модули на компилатора – парсър за синтактично разпознаване на командите в `.ea` файла и генератор на Go код.
   - Разработване на логика за трансформиране на всяка задача в екзекутор (HTTP заявка или Python скрипт) в Go код.

2. **Реализация на базови функционалности**:
   - **HTTP Executor:** Генериране на Go код, който изпраща HTTP заявки въз основа на параметрите в DSL-а (URL, метод, хедъри, тяло на заявката).
   - **Python Executor:** Генериране на Go код, който стартира Docker контейнер и изпълнява вътре в него Python скрипт.

#### Етап 3: Интеграция с Docker

1. **Реализиране на Python Executor**:
   - Използване на Docker API за стартиране на контейнери от Go кода. Всеки екзекютор в нов контейнер.
   - Обработване на връщането на резултатите от контейнерите, като как ще се логва и как ще се управляват грешките при изпълнение на Python скриптовете.

#### Етап 4: Разработка на API и потребителски интерфейс

1. **Разработка на RESTful API с Java Spring Boot**:
   - Създане RESTful API, който приема заявки за изпълнение на DSL файлове. Това API ще получава `.ea` файлове, ще стартира компилатора, ще генерира Go код и ще го изпълнява.
   - Добавяне на функционалности за следене на състоянието на задачите и логване на резултатите от изпълнението.
   - Реализиране на точки за контрол на изпълнението, като старт, пауза, и стоп на процесите.

2. **Изграждане на Angular интерфейс**:
   - Създане на потребителски интерфейс, който позволява на потребителите да качват DSL файлове, да създават нови екзекутори и да управляват вече съществуващи.
   - Включване на визуализация на логовете и резултатите от изпълнените задачи, както и възможност за управление на задачите в реално време.

### 5. **Допълнителни възможности**

1. **Поддръжка на други типове команди**:
   - Добавяне на поддръжка за файлови операции, взаимодействия с бази данни или други специфични команди като част от DSL-а.

2. **Логика за обработка на грешки и ретрай механизми**:
   - Въвеждане на обработка на грешки при неуспешни HTTP заявки или Docker изпълнения. Добавяне на функционалност за повторно изпълнение на задачи при неуспех (ретрай механизъм).

3. **Паралелно изпълнение и синхронизация**:
   - Разработване на механизми за паралелно изпълнение на задачи, осигоряване на синхронизация между различните екзекутори. 

4. **Конфигуриране на системни променливи**:
    - Да може да се конфигурират системни промелниви, на ниво профил, които да се четата от екзекуторите. Екзекуторите да могат да генерират реултат в други такива конфигурации.
